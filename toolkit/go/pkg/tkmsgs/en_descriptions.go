package tkmsgs

import (
	"github.com/hyperledger/firefly-common/pkg/i18n"
	"golang.org/x/text/language"
)

//revive:disable
var ffm = func(key, translation string) i18n.MessageKey {
	return i18n.FFM(language.AmericanEnglish, key, translation)
}

// pldapi/blockindex.go
var (
	IndexedBlockNumber                 = ffm("IndexedBlock.number", "The block number")
	IndexedBlockHash                   = ffm("IndexedBlock.hash", "The unique hash of the block")
	IndexedTransactionHash             = ffm("IndexedTransaction.hash", "The unique hash of the transaction")
	IndexedTransactionBlockNumber      = ffm("IndexedTransaction.blockNumber", "The block number containing this transaction")
	IndexedTransactionTransactionIndex = ffm("IndexedTransaction.transactionIndex", "The index of the transaction within the block")
	IndexedTransactionFrom             = ffm("IndexedTransaction.from", "The sender's Ethereum address")
	IndexedTransactionTo               = ffm("IndexedTransaction.to", "The recipient's Ethereum address (optional)")
	IndexedTransactionNonce            = ffm("IndexedTransaction.nonce", "The transaction nonce")
	IndexedTransactionContractAddress  = ffm("IndexedTransaction.contractAddress", "The contract address created by this transaction (optional)")
	IndexedTransactionResult           = ffm("IndexedTransaction.result", "The result of the transaction (optional)")
	IndexedEventBlockNumber            = ffm("IndexedEvent.blockNumber", "The block number containing this event")
	IndexedEventTransactionIndex       = ffm("IndexedEvent.transactionIndex", "The index of the transaction within the block")
	IndexedEventLogIndex               = ffm("IndexedEvent.logIndex", "The log index of the event")
	IndexedEventTransactionHash        = ffm("IndexedEvent.transactionHash", "The hash of the transaction that triggered this event")
	IndexedEventSignature              = ffm("IndexedEvent.signature", "The event signature")
	IndexedEventTransaction            = ffm("IndexedEvent.transaction", "The transaction that triggered this event (optional)")
	IndexedEventBlock                  = ffm("IndexedEvent.block", "The block containing this event (optional)")
)

// pldapi/keymgr.go
var (
	WalletInfoName                     = ffm("WalletInfo.name", "The name of the wallet")
	WalletInfoKeySelector              = ffm("WalletInfo.keySelector", "The key selector for the wallet")
	KeyMappingIdentifier               = ffm("KeyMapping.identifier", "The full identifier used to look up this key")
	KeyMappingWallet                   = ffm("KeyMapping.wallet", "The name of the wallet containing this key")
	KeyMappingKeyHandle                = ffm("KeyMapping.keyHandle", "The handle within the wallet containing the key")
	KeyMappingWithPathPath             = ffm("KeyMappingWithPath.path", "The full path including the leaf that is the identifier")
	KeyMappingAndVerifierVerifier      = ffm("KeyMappingAndVerifier.verifier", "The verifier associated with this key mapping")
	KeyVerifierWithKeyRefKeyIdentifier = ffm("KeyVerifierWithKeyRef.keyIdentifier", "The identifier of the key associated with this verifier")
	KeyVerifierVerifier                = ffm("KeyVerifier.verifier", "The verifier value")
	KeyVerifierType                    = ffm("KeyVerifier.type", "The type of verifier")
	KeyVerifierAlgorithm               = ffm("KeyVerifier.algorithm", "The algorithm used by the verifier")
	KeyPathSegmentName                 = ffm("KeyPathSegment.name", "The name of the path segment")
	KeyPathSegmentIndex                = ffm("KeyPathSegment.index", "The index of the path segment")
)

// pldapi/public_tx.go
var (
	PublicTxOptionsGas                     = ffm("PublicTxOptions.gas", "The gas limit for the transaction (optional)")
	PublicTxOptionsValue                   = ffm("PublicTxOptions.value", "The value transferred in the transaction (optional)")
	PublicTxGasPricingMaxPriorityFeePerGas = ffm("PublicTxGasPricing.maxPriorityFeePerGas", "The maximum priority fee per gas (optional)")
	PublicTxGasPricingMaxFeePerGas         = ffm("PublicTxGasPricing.maxFeePerGas", "The maximum fee per gas (optional)")
	PublicTxGasPricingGasPrice             = ffm("PublicTxGasPricing.gasPrice", "The gas price (optional)")
	PublicTxInputFrom                      = ffm("PublicTxInput.from", "The resolved signing account")
	PublicTxInputTo                        = ffm("PublicTxInput.to", "The target contract address (optional)")
	PublicTxInputData                      = ffm("PublicTxInput.data", "The pre-encoded calldata (optional)")
	PublicTxSubmissionFrom                 = ffm("PublicTxSubmission.from", "The sender's Ethereum address")
	PublicTxSubmissionNonce                = ffm("PublicTxSubmission.nonce", "The transaction nonce")
	PublicTxSubmissionDataTime             = ffm("PublicTxSubmissionData.time", "The submission time")
	PublicTxSubmissionDataTransactionHash  = ffm("PublicTxSubmissionData.transactionHash", "The transaction hash")
	PublicTxTo                             = ffm("PublicTx.to", "The target contract address (optional)")
	PublicTxData                           = ffm("PublicTx.data", "The pre-encoded calldata (optional)")
	PublicTxFrom                           = ffm("PublicTx.from", "The sender's Ethereum address")
	PublicTxNonce                          = ffm("PublicTx.nonce", "The transaction nonce")
	PublicTxCreated                        = ffm("PublicTx.created", "The creation time")
	PublicTxCompletedAt                    = ffm("PublicTx.completedAt", "The completion time (optional)")
	PublicTxTransactionHash                = ffm("PublicTx.transactionHash", "The transaction hash (optional)")
	PublicTxSuccess                        = ffm("PublicTx.success", "The transaction success status (optional)")
	PublicTxRevertData                     = ffm("PublicTx.revertData", "The revert data (optional)")
	PublicTxSubmissions                    = ffm("PublicTx.submissions", "The submission data (optional)")
	PublicTxActivity                       = ffm("PublicTx.activity", "The transaction activity records (optional)")
	PublicTxBindingTransaction             = ffm("PublicTxBinding.transaction", "The transaction ID")
	PublicTxBindingTransactionType         = ffm("PublicTxBinding.transactionType", "The transaction type")
)

// pldapi/stored_abi.go
var (
	StoredABIHash = ffm("StoredABI.hash", "The unique hash of the ABI")
	StoredABIAPI  = ffm("StoredABI.abi", "The Application Binary Interface (ABI) definition")
)

// pldclient/transaction.go
var (
	TransactionID                                 = ffm("Transaction.id", "Server-generated UUID for this transaction (query only)")
	TransactionCreated                            = ffm("Transaction.created", "Server-generated creation timestamp for this transaction (query only)")
	TransactionIdempotencyKey                     = ffm("Transaction.idempotencyKey", "Externally supplied unique identifier for this transaction. 409 Conflict will be returned on attempt to re-submit")
	TransactionType                               = ffm("Transaction.type", "Type of transaction (public or private)")
	TransactionDomain                             = ffm("Transaction.domain", "Name of a domain - only required on input for private deploy transactions")
	TransactionFunction                           = ffm("Transaction.function", "Function signature - inferred from definition if not supplied")
	TransactionABIReference                       = ffm("Transaction.abiReference", "Calculated ABI reference - required with ABI on input if not constructor")
	TransactionFrom                               = ffm("Transaction.from", "Locator for a local signing identity to use for submission of this transaction")
	TransactionTo                                 = ffm("Transaction.to", "Target contract address, or null for a deploy")
	TransactionData                               = ffm("Transaction.data", "Pre-encoded array with/without function selector, array, or object input")
	TransactionInputDependsOn                     = ffm("TransactionInput.dependsOn", "Transactions that must be mined on the blockchain successfully before this transaction submits")
	TransactionInputABI                           = ffm("TransactionInput.abi", "Application Binary Interface (ABI) definition - required if abiReference not supplied")
	TransactionInputBytecode                      = ffm("TransactionInput.bytecode", "Bytecode prepended to encoded data inputs for deploy transactions")
	TransactionFullDependsOn                      = ffm("TransactionFull.dependsOn", "Transactions registered as dependencies when the transaction was created")
	TransactionFullReceipt                        = ffm("TransactionFull.receipt", "Transaction receipt data - available if the transaction has reached a final state")
	TransactionFullPublic                         = ffm("TransactionFull.public", "List of public transactions associated with this transaction")
	TransactionReceiptID                          = ffm("TransactionReceipt.id", "Transaction ID")
	TransactionReceiptDataOnchainTransactionHash  = ffm("TransactionReceiptDataOnchain.transactionHash", "Transaction hash")
	TransactionReceiptDataOnchainBlockNumber      = ffm("TransactionReceiptDataOnchain.blockNumber", "Block number")
	TransactionReceiptDataOnchainTransactionIndex = ffm("TransactionReceiptDataOnchain.transactionIndex", "Transaction index")
	TransactionReceiptDataOnchainEventLogIndex    = ffm("TransactionReceiptDataOnchainEvent.logIndex", "Log index")
	TransactionReceiptDataOnchainEventSource      = ffm("TransactionReceiptDataOnchainEvent.source", "Event source")
	TransactionReceiptDataSuccess                 = ffm("TransactionReceiptData.success", "Transaction success status")
	TransactionReceiptDataFailureMessage          = ffm("TransactionReceiptData.failureMessage", "Failure message - set if transaction reverted")
	TransactionReceiptDataRevertData              = ffm("TransactionReceiptData.revertData", "Encoded revert data - if available")
	TransactionReceiptDataContractAddress         = ffm("TransactionReceiptData.contractAddress", "New contract address - to be used in the 'To' field for subsequent invoke transactions")
	TransactionActivityRecordTime                 = ffm("TransactionActivityRecord.time", "Time the record occurred")
	TransactionActivityRecordMessage              = ffm("TransactionActivityRecord.message", "Activity message")
	TransactionDependenciesDependsOn              = ffm("TransactionDependencies.dependsOn", "Transactions that this transaction depends on")
	TransactionDependenciesPrereqOf               = ffm("TransactionDependencies.prereqOf", "Transactions that require this transaction as a prerequisite")
)

// query/query_json.go
var (
	QueryJSONStatements         = ffm("QueryJSON.statements", "Query statements")
	QueryJSONLimit              = ffm("QueryJSON.limit", "Query limit")
	QueryJSONSort               = ffm("QueryJSON.sort", "Query sort order")
	FilterResultsWithCountCount = ffm("FilterResultsWithCount.count", "Number of items returned")
	FilterResultsWithCountTotal = ffm("FilterResultsWithCount.total", "Total number of items available")
	FilterResultsWithCountItems = ffm("FilterResultsWithCount.items", "Returned items")
	ItemsResultTypedCount       = ffm("ItemsResultTyped.count", "Number of items returned")
	ItemsResultTypedTotal       = ffm("ItemsResultTyped.total", "Total number of items available")
	ItemsResultTypedItems       = ffm("ItemsResultTyped.items", "Returned items")
	OpNot                       = ffm("Op.not", "Negate the operation")
	OpCaseInsensitive           = ffm("Op.caseInsensitive", "Perform case-insensitive matching")
	OpField                     = ffm("Op.field", "Field to apply the operation to")
	OpSingleValValue            = ffm("OpSingleVal.value", "Value to compare against")
	OpMultiValValues            = ffm("OpMultiVal.values", "Values to compare against")
	StatementsOr                = ffm("Statements.or", "List of alternative statements")
	OpsEqual                    = ffm("Ops.equal", "Equal to")
	OpsEq                       = ffm("Ops.eq", "Equal to (short name)")
	OpsNEq                      = ffm("Ops.neq", "Not equal to")
	OpsLike                     = ffm("Ops.like", "Like")
	OpsLessThan                 = ffm("Ops.lessThan", "Less than")
	OpsLT                       = ffm("Ops.lt", "Less than (short name)")
	OpsLessThanOrEqual          = ffm("Ops.lessThanOrEqual", "Less than or equal to")
	OpsLTE                      = ffm("Ops.lte", "Less than or equal to (short name)")
	OpsGreaterThan              = ffm("Ops.greaterThan", "Greater than")
	OpsGT                       = ffm("Ops.gt", "Greater than (short name)")
	OpsGreaterThanOrEqual       = ffm("Ops.greaterThanOrEqual", "Greater than or equal to")
	OpsGTE                      = ffm("Ops.gte", "Greater than or equal to (short name)")
	OpsIn                       = ffm("Ops.in", "In")
	OpsNIn                      = ffm("Ops.nin", "Not in")
	OpsNull                     = ffm("Ops.null", "Null")
)
