group = 'io.kaleido'

// Define core projects to be assembled and built
def coreProjects = [
    ':core:go',
    ':toolkit:go',
    ':core:java'
]

// Define a list of source directories to copy from
def buildLibs = [
    'core/go/build/libs',
    'core/java/build/libs',
    'toolkit/go/build/libs'
]

def artifacts = [
    'solidity/artifacts'
]
ext {
    helpers = [
        lockResource: { task, lockFile ->
            // If two tasks share an output file, they will not be able to run concurrently.
            // This helper creates an empty "lock" file in the root build directory, which allows
            // tasks to use it as a representation of some shared resource.
            def f = new File(task.project.rootProject.buildDir, lockFile)
            task.outputs.file(f)
            task.doLast { f.createNewFile() }
        },

        dumpLogsOnFailure: { task, dockerTaskPath ->
            // If invoked with -PcomposeLogs=true and the given Exec task fails, look up the
            // DockerCompose task specified, and ask it to dump logs.
            task.ignoreExitValue(true)
            task.doLast {
                def execResult = getExecutionResult().get()
                def composeLogs = project.findProperty('composeLogs')
                if (execResult.exitValue != 0 && composeLogs == "true") {
                    def docker = project.tasks.getByPath(dockerTaskPath)
                    println "\nTask '${task.path}' failed. Dumping Docker logs from '${dockerTaskPath}'."
                    docker.dumpLogs()
                }
                execResult.assertNormalExitValue()
            }
        }
    ]
}

subprojects {
    apply plugin: 'base'

    repositories {
        mavenCentral()
    }
}

// Task to copy all executables and binaries to the root-level build/libs directory
task copyExecutables(type: Copy) {

    // Define the root build directory
    def libsDir = file("${buildDir}/libs")

    doFirst {
        libsDir.mkdirs()
    }

    // copy binaries from the defined directories
    buildLibs.each { dir ->
        from dir
    }
    into libsDir
 
    // Ensure this task always runs
    outputs.upToDateWhen { false }
    
    doLast {
        println "Copied executables to ${libsDir}"
    }
}

// Task to copy all executables and binaries to the root-level build/libs directory
task copyArtifacts(type: Copy) {

    // Define the root build directory
    def artifactsDir = file("${buildDir}/artifacts")

    doFirst {
        artifactsDir.mkdirs()
    }

    // copy binaries from the defined directories
    artifacts.each { dir ->
        from dir
    }
    into artifactsDir

    // Ensure this task always runs
    outputs.upToDateWhen { false }
    
    doLast {
        println "Copied artifacts to ${artifactsDir}"
    }
}

// Root-level `assemble` task, only for core projects
task assemble {
    
    // Ensure root assemble task depends on subprojects' assemble tasks
    coreProjects.each { projectPath ->
        dependsOn "${projectPath}:assemble"
    }
    
    finalizedBy copyExecutables, copyArtifacts  // Ensure executables are copied after assembly
    
}

// Root-level `build` task, only for core projects
task build {

}

// Set default tasks
defaultTasks 'build'

// Clean task to clean all projects
task clean {
    delete "${buildDir}"
}
