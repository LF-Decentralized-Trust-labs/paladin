/*
 * Copyright Â© 2024 Kaleido, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

package publictxmgr

import (
	"context"
	"fmt"
	"math/big"
	"testing"
	"time"

	"github.com/hyperledger/firefly-common/pkg/fftypes"
	"github.com/hyperledger/firefly-signer/pkg/ethtypes"
	baseTypes "github.com/kaleido-io/paladin/core/internal/engine/enginespi"
	"github.com/kaleido-io/paladin/core/pkg/ethclient"
	"github.com/kaleido-io/paladin/toolkit/pkg/confutil"
	"github.com/kaleido-io/paladin/toolkit/pkg/tktypes"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
)

func TestProduceLatestInFlightStageContextSubmitPanic(t *testing.T) {
	ctx := context.Background()
	testInFlightTransactionStateManagerWithMocks := NewTestInFlightTransactionWithMocks(t)
	it := testInFlightTransactionStateManagerWithMocks.it

	// switch to submit
	inFlightStageMananger := it.stateManager.(*inFlightTransactionState)
	signedMsg := []byte("signedMessage")
	it.TriggerNewStageRun(ctx, baseTypes.InFlightTxStageSubmitting, PubTxSubStatusReceived, signedMsg)
	rsc := it.stateManager.GetRunningStageContext(ctx)

	// unexpected error
	inFlightStageMananger.bufferedStageOutputs = make([]*baseTypes.StageOutput, 0)
	it.stateManager.AddPanicOutput(ctx, baseTypes.InFlightTxStageSubmitting)
	tOut := it.ProduceLatestInFlightStageContext(ctx, &baseTypes.OrchestratorContext{
		AvailableToSpend:         nil,
		PreviousNonceCostUnknown: true,
	})
	assert.NotEmpty(t, *tOut)
	assert.Regexp(t, "PD011919", tOut.Error)
	assert.NotEqual(t, rsc, it.stateManager.GetRunningStageContext(ctx))
	// rolled back to signing stage as per current design
	rsc = it.stateManager.GetRunningStageContext(ctx)
	assert.Equal(t, baseTypes.InFlightTxStageSigning, rsc.Stage)

}

func TestProduceLatestInFlightStageContextSubmitComplete(t *testing.T) {
	ctx := context.Background()
	testInFlightTransactionStateManagerWithMocks := NewTestInFlightTransactionWithMocks(t)
	it := testInFlightTransactionStateManagerWithMocks.it
	// switch to submit
	inFlightStageMananger := it.stateManager.(*inFlightTransactionState)
	signedMsg := []byte("signedMessage")
	txHash := confutil.P(tktypes.Bytes32Keccak([]byte("0x000031")))
	it.TriggerNewStageRun(ctx, baseTypes.InFlightTxStageSubmitting, PubTxSubStatusReceived, signedMsg)
	rsc := it.stateManager.GetRunningStageContext(ctx)
	// submission attempt completed - new transaction submitted
	inFlightStageMananger.bufferedStageOutputs = make([]*baseTypes.StageOutput, 0)
	mtx := it.stateManager.GetTx()
	mtx.TransactionHash = nil
	mTS := testInFlightTransactionStateManagerWithMocks.mTS
	mtx.FirstSubmit = nil
	mtx.SubmittedHashes = []string{}

	submissionTime := confutil.P(tktypes.TimestampNow())
	it.stateManager.AddSubmitOutput(ctx, txHash, submissionTime, baseTypes.SubmissionOutcomeSubmittedNew, ethclient.ErrorReason(""), nil)
	rsc.StageOutputsToBePersisted = nil
	tOut := it.ProduceLatestInFlightStageContext(ctx, &baseTypes.OrchestratorContext{
		AvailableToSpend:         nil,
		PreviousNonceCostUnknown: false,
	})
	assert.NotEmpty(t, *tOut)
	assert.Equal(t, "20000", tOut.Cost.String())
	assert.Equal(t, baseTypes.InFlightTxStageSubmitting, rsc.Stage)
	assert.NotNil(t, rsc.StageOutputsToBePersisted)
	assert.Equal(t, 1, len(rsc.StageOutputsToBePersisted.StatusUpdates))
	mTS.On("UpdateSubStatus", mock.Anything, mtx.ID.String(), PubTxSubStatusReceived, BaseTxActionSubmitTransaction, fftypes.JSONAnyPtr(`{"txHash":"`+txHash.String()+`"}`), (*fftypes.JSONAny)(nil), mock.Anything).Return(nil).Maybe()
	_ = rsc.StageOutputsToBePersisted.StatusUpdates[0](mTS)
	assert.Equal(t, txHash, rsc.StageOutputsToBePersisted.TxUpdates.TransactionHash)
	assert.Equal(t, submissionTime, rsc.StageOutputsToBePersisted.TxUpdates.FirstSubmit)
	assert.Equal(t, submissionTime, rsc.StageOutputsToBePersisted.TxUpdates.LastSubmit)

	// submission attempt completed - nonce too low
	inFlightStageMananger.bufferedStageOutputs = make([]*baseTypes.StageOutput, 0)
	rsc = it.stateManager.GetRunningStageContext(ctx)
	mtx.SubmittedHashes = []string{}
	it.stateManager.AddSubmitOutput(ctx, txHash, submissionTime, baseTypes.SubmissionOutcomeNonceTooLow, ethclient.ErrorReason(""), nil)
	rsc.StageOutputsToBePersisted = nil
	tOut = it.ProduceLatestInFlightStageContext(ctx, &baseTypes.OrchestratorContext{
		AvailableToSpend:         nil,
		PreviousNonceCostUnknown: false,
	})
	assert.NotEmpty(t, *tOut)
	assert.Equal(t, "20000", tOut.Cost.String())
	assert.Equal(t, baseTypes.InFlightTxStageSubmitting, rsc.Stage)
	assert.NotNil(t, rsc.StageOutputsToBePersisted)
	mTS.On("UpdateSubStatus", mock.Anything, mtx.ID.String(), PubTxSubStatusReceived, BaseTxActionSubmitTransaction, fftypes.JSONAnyPtr(`{"txHash":"`+txHash.String()+`"}`), (*fftypes.JSONAny)(nil), mock.Anything).Return(nil).Maybe()
	_ = rsc.StageOutputsToBePersisted.StatusUpdates[0](mTS)
	assert.Equal(t, submissionTime, rsc.StageOutputsToBePersisted.TxUpdates.LastSubmit)
	assert.Equal(t, txHash, rsc.StageOutputsToBePersisted.TxUpdates.TransactionHash)
}

func TestProduceLatestInFlightStageContextCannotSubmit(t *testing.T) {
	ctx := context.Background()
	testInFlightTransactionStateManagerWithMocks := NewTestInFlightTransactionWithMocks(t)
	it := testInFlightTransactionStateManagerWithMocks.it
	// switch to submit
	inFlightStageMananger := it.stateManager.(*inFlightTransactionState)
	// Previous cost unknown when state is not validated
	inFlightStageMananger.bufferedStageOutputs = make([]*baseTypes.StageOutput, 0)
	mtx := it.stateManager.GetTx()
	mtx.GasPrice = nil
	mtx.MaxFeePerGas = tktypes.Uint64ToUint256(32247127816)
	mtx.MaxPriorityFeePerGas = tktypes.Uint64ToUint256(32146027800)

	mtx.TransactionHash = nil
	mtx.FirstSubmit = nil
	mtx.SubmittedHashes = []string{}

	tOut := it.ProduceLatestInFlightStageContext(ctx, &baseTypes.OrchestratorContext{
		AvailableToSpend:         big.NewInt(0),
		PreviousNonceCostUnknown: true, // previous cost unknown, cannot submit
	})
	assert.NotEmpty(t, *tOut)
	assert.Equal(t, "64494255632000", tOut.Cost.String())
	assert.False(t, tOut.TransactionSubmitted)

	// Previous cost unknown when state is validated
	inFlightStageMananger.bufferedStageOutputs = make([]*baseTypes.StageOutput, 0)
	mtx.TransactionHash = confutil.P(tktypes.Bytes32Keccak([]byte("test")))
	mtx.SubmittedHashes = []string{}
	mtx.GasLimit = tktypes.Uint64ToUint256(-1) // invalid limit
	it.stateManager.SetValidatedTransactionHashMatchState(ctx, false)
	tOut = it.ProduceLatestInFlightStageContext(ctx, &baseTypes.OrchestratorContext{
		AvailableToSpend:         big.NewInt(0),
		PreviousNonceCostUnknown: true, // previous cost unknown, cannot submit
	})
	assert.NotEmpty(t, *tOut)
	assert.Nil(t, tOut.Cost) // cost cannot be calculated
	assert.True(t, tOut.TransactionSubmitted)
}
func TestProduceLatestInFlightStageContextSubmitCompleteAlreadyKnown(t *testing.T) {
	ctx := context.Background()
	testInFlightTransactionStateManagerWithMocks := NewTestInFlightTransactionWithMocks(t)
	it := testInFlightTransactionStateManagerWithMocks.it

	// switch to submit
	inFlightStageMananger := it.stateManager.(*inFlightTransactionState)
	signedMsg := []byte("signedMessage")
	txHash := confutil.P(tktypes.Bytes32Keccak([]byte("0x000031")))
	it.TriggerNewStageRun(ctx, baseTypes.InFlightTxStageSubmitting, PubTxSubStatusReceived, signedMsg)
	rsc := it.stateManager.GetRunningStageContext(ctx)
	// submission attempt completed - new transaction submitted
	inFlightStageMananger.bufferedStageOutputs = make([]*baseTypes.StageOutput, 0)
	mtx := it.stateManager.GetTx()
	mtx.TransactionHash = nil
	mtx.FirstSubmit = nil
	mtx.SubmittedHashes = []string{}

	submissionTime := confutil.P(tktypes.TimestampNow())
	// // submission attempt completed - already known
	inFlightStageMananger.bufferedStageOutputs = make([]*baseTypes.StageOutput, 0)
	rsc.StageOutputsToBePersisted = nil
	mtx.FirstSubmit = confutil.P(tktypes.TimestampNow())
	rsc = it.stateManager.GetRunningStageContext(ctx)
	mtx.SubmittedHashes = []string{}
	it.stateManager.AddSubmitOutput(ctx, txHash, submissionTime, baseTypes.SubmissionOutcomeAlreadyKnown, ethclient.ErrorReason(""), nil)
	tOut := it.ProduceLatestInFlightStageContext(ctx, &baseTypes.OrchestratorContext{
		AvailableToSpend:         nil,
		PreviousNonceCostUnknown: false,
	})
	assert.NotEmpty(t, *tOut)
	assert.Equal(t, "20000", tOut.Cost.String())
	assert.Equal(t, baseTypes.InFlightTxStageSubmitting, rsc.Stage)
	assert.NotNil(t, rsc.StageOutputsToBePersisted)
	assert.Empty(t, rsc.StageOutputsToBePersisted.StatusUpdates)
	assert.Equal(t, txHash, rsc.StageOutputsToBePersisted.TxUpdates.TransactionHash)

	// submission attempt completed - already known for the first time submission
	inFlightStageMananger.bufferedStageOutputs = make([]*baseTypes.StageOutput, 0)
	rsc.StageOutputsToBePersisted = nil
	mtx.FirstSubmit = nil
	rsc = it.stateManager.GetRunningStageContext(ctx)
	mtx.SubmittedHashes = []string{}
	it.stateManager.AddSubmitOutput(ctx, txHash, submissionTime, baseTypes.SubmissionOutcomeAlreadyKnown, ethclient.ErrorReason(""), nil)
	tOut = it.ProduceLatestInFlightStageContext(ctx, &baseTypes.OrchestratorContext{
		AvailableToSpend:         nil,
		PreviousNonceCostUnknown: false,
	})
	assert.NotEmpty(t, *tOut)
	assert.Equal(t, "20000", tOut.Cost.String())
	assert.Equal(t, baseTypes.InFlightTxStageSubmitting, rsc.Stage)
	assert.NotNil(t, rsc.StageOutputsToBePersisted)
	assert.Empty(t, rsc.StageOutputsToBePersisted.StatusUpdates)
	assert.Equal(t, txHash, rsc.StageOutputsToBePersisted.TxUpdates.TransactionHash)

	// submission attempt completed - already known for the an existing time submission
	inFlightStageMananger.bufferedStageOutputs = make([]*baseTypes.StageOutput, 0)
	rsc.StageOutputsToBePersisted = nil
	mtx.FirstSubmit = confutil.P(tktypes.TimestampNow())
	mtx.TransactionHash = confutil.P(tktypes.Bytes32Keccak([]byte("already known")))
	rsc = it.stateManager.GetRunningStageContext(ctx)
	mtx.SubmittedHashes = []string{}
	it.stateManager.AddSubmitOutput(ctx, txHash, submissionTime, baseTypes.SubmissionOutcomeAlreadyKnown, ethclient.ErrorReason(""), nil)
	tOut = it.ProduceLatestInFlightStageContext(ctx, &baseTypes.OrchestratorContext{
		AvailableToSpend:         nil,
		PreviousNonceCostUnknown: false,
	})
	assert.NotEmpty(t, *tOut)
	assert.Equal(t, "20000", tOut.Cost.String())
	assert.Equal(t, baseTypes.InFlightTxStageSubmitting, rsc.Stage)
	assert.NotNil(t, rsc.StageOutputsToBePersisted)
	assert.Empty(t, rsc.StageOutputsToBePersisted.StatusUpdates)
	assert.Equal(t, txHash, rsc.StageOutputsToBePersisted.TxUpdates.TransactionHash)
}
func TestProduceLatestInFlightStageContextSubmitErrors(t *testing.T) {
	ctx := context.Background()
	testInFlightTransactionStateManagerWithMocks := NewTestInFlightTransactionWithMocks(t)
	it := testInFlightTransactionStateManagerWithMocks.it
	// switch to submit
	inFlightStageMananger := it.stateManager.(*inFlightTransactionState)
	signedMsg := []byte("signedMessage")
	txHash := confutil.P(tktypes.Bytes32Keccak([]byte("0x000001")))
	mTS := testInFlightTransactionStateManagerWithMocks.mTS

	it.TriggerNewStageRun(ctx, baseTypes.InFlightTxStageSubmitting, PubTxSubStatusReceived, signedMsg)
	rsc := it.stateManager.GetRunningStageContext(ctx)

	mtx := it.stateManager.GetTx()
	mtx.TransactionHash = nil
	mtx.FirstSubmit = nil
	mtx.SubmittedHashes = []string{}
	submissionTime := confutil.P(tktypes.TimestampNow())
	submissionErr := fmt.Errorf("submission error")

	// submission attempt errored - required re-preparation
	inFlightStageMananger.bufferedStageOutputs = make([]*baseTypes.StageOutput, 0)
	rsc.StageOutputsToBePersisted = nil
	rsc = it.stateManager.GetRunningStageContext(ctx)
	it.stateManager.AddSubmitOutput(ctx, txHash, submissionTime, baseTypes.SubmissionOutcomeFailedRequiresRetry, ethclient.ErrorReasonTransactionReverted, submissionErr)
	tOut := it.ProduceLatestInFlightStageContext(ctx, &baseTypes.OrchestratorContext{
		AvailableToSpend:         nil,
		PreviousNonceCostUnknown: false,
	})

	assert.NotEmpty(t, *tOut)
	assert.Equal(t, "20000", tOut.Cost.String())
	assert.False(t, tOut.TransactionSubmitted)
	assert.Equal(t, baseTypes.InFlightTxStageSubmitting, rsc.Stage)
	assert.NotNil(t, rsc.StageOutputsToBePersisted)
	assert.Equal(t, 1, len(rsc.StageOutputsToBePersisted.StatusUpdates))
	called := make(chan bool, 3)
	mTS.On("UpdateSubStatus", mock.Anything, mtx.ID.String(), PubTxSubStatusReceived, BaseTxActionSubmitTransaction, fftypes.JSONAnyPtr(`{"reason":"`+string(ethclient.ErrorReasonTransactionReverted)+`"}`), fftypes.JSONAnyPtr(`{"error":"`+submissionErr.Error()+`"}`), mock.Anything).Run(func(args mock.Arguments) {
		called <- true
	}).Return(nil).Maybe()
	_ = rsc.StageOutputsToBePersisted.StatusUpdates[0](mTS)
	<-called
	assert.Equal(t, submissionErr.Error(), *rsc.StageOutputsToBePersisted.TxUpdates.ErrorMessage)
	assert.Equal(t, baseTypes.InFlightTxStageSubmitting, rsc.Stage)
	assert.Nil(t, rsc.StageOutputsToBePersisted.TxUpdates.NewSubmittedHashes)

	// submission attempt errored - required re-preparation during resubmission
	inFlightStageMananger.bufferedStageOutputs = make([]*baseTypes.StageOutput, 0)
	rsc.StageOutputsToBePersisted = nil
	rsc = it.stateManager.GetRunningStageContext(ctx)
	newWarnTime := confutil.P(tktypes.TimestampNow())
	mtx.TransactionHash = txHash
	it.stateManager.AddSubmitOutput(ctx, nil, newWarnTime, baseTypes.SubmissionOutcomeFailedRequiresRetry, ethclient.ErrorReasonTransactionReverted, submissionErr)
	tOut = it.ProduceLatestInFlightStageContext(ctx, &baseTypes.OrchestratorContext{
		AvailableToSpend:         nil,
		PreviousNonceCostUnknown: false,
	})

	assert.NotEmpty(t, *tOut)
	assert.Equal(t, "20000", tOut.Cost.String())
	assert.True(t, tOut.TransactionSubmitted)
	assert.Equal(t, baseTypes.InFlightTxStageSubmitting, rsc.Stage)
	assert.NotNil(t, rsc.StageOutputsToBePersisted)
	assert.Equal(t, 1, len(rsc.StageOutputsToBePersisted.StatusUpdates))
	called = make(chan bool, 3)
	mTS.On("UpdateSubStatus", mock.Anything, mtx.ID.String(), PubTxSubStatusReceived, BaseTxActionSubmitTransaction, fftypes.JSONAnyPtr(`{"reason":"`+string(ethclient.ErrorReasonTransactionReverted)+`"}`), fftypes.JSONAnyPtr(`{"error":"`+submissionErr.Error()+`"}`), mock.Anything).Run(func(args mock.Arguments) {
		called <- true
	}).Return(nil).Maybe()
	_ = rsc.StageOutputsToBePersisted.StatusUpdates[0](mTS)
	<-called
	assert.Equal(t, submissionErr.Error(), *rsc.StageOutputsToBePersisted.TxUpdates.ErrorMessage)
	assert.Equal(t, baseTypes.InFlightTxStageSubmitting, rsc.Stage)
	assert.NotNil(t, rsc.StageOutputsToBePersisted.TxUpdates)
	assert.NotNil(t, rsc.StageOutputsToBePersisted.TxUpdates.LastSubmit)

	// persisting error waiting for persistence retry timeout
	assert.False(t, rsc.StageErrored)
	it.persistenceRetryTimeout = 5 * time.Second
	inFlightStageMananger.bufferedStageOutputs = make([]*baseTypes.StageOutput, 0)
	it.stateManager.AddPersistenceOutput(ctx, baseTypes.InFlightTxStageSubmitting, time.Now().Add(it.persistenceRetryTimeout*2), fmt.Errorf("persist signing sub-status error"))
	it.ProduceLatestInFlightStageContext(ctx, &baseTypes.OrchestratorContext{
		AvailableToSpend:         nil,
		PreviousNonceCostUnknown: false,
	})

	// persisted stage error - required more funds
	rsc = it.stateManager.GetRunningStageContext(ctx)
	rsc.StageOutput = &baseTypes.StageOutput{
		SubmitOutput: &baseTypes.SubmitOutputs{
			SubmissionOutcome: baseTypes.SubmissionOutcomeFailedRequiresRetry,
			ErrorReason:       string(ethclient.ErrorReasonInsufficientFunds),
			Err:               fmt.Errorf("insufficient funds"),
		},
	}
	inFlightStageMananger.bufferedStageOutputs = make([]*baseTypes.StageOutput, 0)
	it.stateManager.AddPersistenceOutput(ctx, baseTypes.InFlightTxStageSubmitting, time.Now(), nil)
	it.ProduceLatestInFlightStageContext(ctx, &baseTypes.OrchestratorContext{
		AvailableToSpend:         nil,
		PreviousNonceCostUnknown: false,
	})
	rsc = it.stateManager.GetRunningStageContext(ctx)
	assert.True(t, rsc.StageErrored)

	// persisting error retrying
	it.persistenceRetryTimeout = 0
	inFlightStageMananger.bufferedStageOutputs = make([]*baseTypes.StageOutput, 0)
	it.stateManager.AddPersistenceOutput(ctx, baseTypes.InFlightTxStageSubmitting, time.Now(), fmt.Errorf("persist submit error"))
	it.ProduceLatestInFlightStageContext(ctx, &baseTypes.OrchestratorContext{
		AvailableToSpend:         nil,
		PreviousNonceCostUnknown: false,
	})
	it.persistenceRetryTimeout = 5 * time.Second

}

func TestProduceLatestInFlightStageContextSubmitRePrepare(t *testing.T) {
	ctx := context.Background()
	testInFlightTransactionStateManagerWithMocks := NewTestInFlightTransactionWithMocks(t)
	it := testInFlightTransactionStateManagerWithMocks.it

	// switch to submit
	inFlightStageMananger := it.stateManager.(*inFlightTransactionState)
	signedMsg := []byte("signedMessage")

	it.TriggerNewStageRun(ctx, baseTypes.InFlightTxStageSubmitting, PubTxSubStatusReceived, signedMsg)

	mtx := it.stateManager.GetTx()
	mtx.TransactionHash = nil
	mtx.FirstSubmit = nil
	mtx.SubmittedHashes = []string{}
	// persisted stage error - require re-preparation
	inFlightStageMananger.bufferedStageOutputs = make([]*baseTypes.StageOutput, 0)
	it.stateManager.AddPersistenceOutput(ctx, baseTypes.InFlightTxStageSubmitting, time.Now(), nil)
	rsc := it.stateManager.GetRunningStageContext(ctx)
	rsc.StageOutput = &baseTypes.StageOutput{
		SubmitOutput: &baseTypes.SubmitOutputs{
			SubmissionOutcome: baseTypes.SubmissionOutcomeFailedRequiresRetry,
			ErrorReason:       string(ethclient.ErrorReasonInsufficientFunds),
			Err:               fmt.Errorf("insufficient funds"),
		},
	}
	it.ProduceLatestInFlightStageContext(ctx, &baseTypes.OrchestratorContext{
		AvailableToSpend:         nil,
		PreviousNonceCostUnknown: false,
	})
	assert.True(t, rsc.StageErrored)
	assert.Equal(t, baseTypes.InFlightTxStageSubmitting, inFlightStageMananger.stage)
}

func TestProduceLatestInFlightStageContextSubmitSuccess(t *testing.T) {
	ctx := context.Background()
	testInFlightTransactionStateManagerWithMocks := NewTestInFlightTransactionWithMocks(t)
	it := testInFlightTransactionStateManagerWithMocks.it

	// switch to submit
	inFlightStageMananger := it.stateManager.(*inFlightTransactionState)
	signedMsg := []byte("signedMessage")

	it.TriggerNewStageRun(ctx, baseTypes.InFlightTxStageSubmitting, PubTxSubStatusReceived, signedMsg)

	mtx := it.stateManager.GetTx()
	mtx.SubmittedHashes = []string{}

	// persisted stage error - require re-preparation
	inFlightStageMananger.bufferedStageOutputs = make([]*baseTypes.StageOutput, 0)
	it.stateManager.AddPersistenceOutput(ctx, baseTypes.InFlightTxStageSubmitting, time.Now(), nil)
	rsc := it.stateManager.GetRunningStageContext(ctx)
	it.stateManager.SetValidatedTransactionHashMatchState(ctx, false)
	rsc.StageOutput = &baseTypes.StageOutput{
		SubmitOutput: &baseTypes.SubmitOutputs{
			SubmissionOutcome: baseTypes.SubmissionOutcomeSubmittedNew,
		},
	}
	it.ProduceLatestInFlightStageContext(ctx, &baseTypes.OrchestratorContext{
		AvailableToSpend:         nil,
		PreviousNonceCostUnknown: false,
	})

	// switched to tracking
	assert.Equal(t, baseTypes.InFlightTxStageConfirming, inFlightStageMananger.stage)
	assert.True(t, it.stateManager.ValidatedTransactionHashMatchState(ctx))

}

func TestProduceLatestInFlightStageContextTriggerSubmit(t *testing.T) {
	ctx := context.Background()
	testInFlightTransactionStateManagerWithMocks := NewTestInFlightTransactionWithMocks(t)
	it := testInFlightTransactionStateManagerWithMocks.it
	it.testOnlyNoActionMode = false
	it.testOnlyNoEventMode = false
	// trigger signing
	mtx := it.stateManager.GetTx()
	mtx.TransactionHash = nil
	assert.Nil(t, it.stateManager.GetRunningStageContext(ctx))
	mEC := testInFlightTransactionStateManagerWithMocks.mEC
	called := make(chan struct{})

	sendRawTransactionMock := mEC.On("SendRawTransaction", ctx, mock.Anything)
	sendRawTransactionMock.Run(func(args mock.Arguments) {
		sendRawTransactionMock.Return(nil, fmt.Errorf("pop"))
		close(called)
	}).Once()
	err := it.TriggerSubmitTx(ctx, nil)
	require.NoError(t, err)
	<-called
	inFlightStageMananger := it.stateManager.(*inFlightTransactionState)
	for len(inFlightStageMananger.bufferedStageOutputs) == 0 {
		// wait for event
	}
	assert.Len(t, inFlightStageMananger.bufferedStageOutputs, 1)
	assert.NotNil(t, inFlightStageMananger.bufferedStageOutputs[0].SubmitOutput)
	assert.NotNil(t, inFlightStageMananger.bufferedStageOutputs[0].SubmitOutput.Err)
	assert.Empty(t, inFlightStageMananger.bufferedStageOutputs[0].SubmitOutput.TxHash)
	assert.Empty(t, inFlightStageMananger.bufferedStageOutputs[0].SubmitOutput.ErrorReason)
	assert.NotEmpty(t, inFlightStageMananger.bufferedStageOutputs[0].SubmitOutput.SubmissionTime)
	assert.Equal(t, baseTypes.SubmissionOutcomeFailedRequiresRetry, inFlightStageMananger.bufferedStageOutputs[0].SubmitOutput.SubmissionOutcome)
}
