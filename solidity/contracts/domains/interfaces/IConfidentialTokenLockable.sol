// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.20;

import {IConfidentialToken} from "./IConfidentialToken.sol";

/**
 * @title IConfidentialTIConfidentialTokenLockableoken
 * @dev Extensions for locking/unlocking UTXOs.
 */
interface IConfidentialTokenLockable is IConfidentialToken {
    // State parameters for lock() - wrapped in a struct to avoid stack too deep errors
    struct LockStates {
        // Array of zero or more UTXOs that the signer is authorized to spend
        bytes32[] inputs;

        // Array of zero or more new UTXOs to generate, for future transactions to spend
        bytes32[] outputs;

        // Array of zero or more locked UTXOs to generate, which will be tied to the lockId
        bytes32[] lockedOutputs;
    }

    event Locked(
        bytes32 txId,
        address indexed operator,
        bytes32 lockId,
        LockStates states,
        address delegate,
        bytes options,
        bytes proof,
        bytes data
    );

    event TransferLocked(
        bytes32 txId,
        address indexed operator,
        bytes32 lockId,
        bytes32[] lockedInputs,
        bytes32[] lockedOutputs,
        bytes32[] outputs,
        bytes proof,
        bytes data
    );

    event LockUpdated(
        bytes32 txId,
        address indexed operator,
        bytes32 lockId,
        bytes32[] lockedInputs,
        bytes options,
        bytes proof,
        bytes data
    );

    event LockDelegated(
        bytes32 txId,
        address indexed operator,
        bytes32 lockId,
        address delegate,
        bytes proof,
        bytes data
    );

    /**
     * @dev Spend UTXOs and create new locked UTXOs.
     *      Locks are identified by a unique lockId, which is generated by the caller.
     *      Locked states can be spent using transferLocked() or burnLocked(), or
     *      control of the UTXOs can be delegated to another address.
     *
     * @param txId a unique identifier for this transaction which must not have been used before
     * @param lockId unique identifier for the lock
     * @param states the input and output states (see LockStates struct)
     * @param delegate the address of the delegate who can spend the locked states
     *                 (may be zero to set no delegate)
     * @param options implementation-specific options that control how the lock may be utilized
     *                (may include restrictions on how it may be unlocked, expiration times, etc)
     * @param proof implementation-specific proof for this transaction - may be validated by
     *              the smart contract, or may represent evidence of off-chain validation
     * @param data any additional transaction data (opaque to the blockchain)
     *
     * Emits a {Locked} event.
     */
    function lock(
        bytes32 txId,
        bytes32 lockId,
        LockStates calldata states,
        address delegate,
        bytes calldata options,
        bytes calldata proof,
        bytes calldata data
    ) external;

    /**
     * @dev Directly create new locked UTXOs.
     *      Behavior should be identical to lock(), but may come with different constraints on execution.
     */
    function mintLocked(
        bytes32 txId,
        bytes32 lockId,
        bytes32[] calldata lockedOutputs,
        address delegate,
        bytes calldata options,
        bytes calldata proof,
        bytes calldata data
    ) external;

    /**
     * @dev Spend locked UTXOs and create new (locked or unlocked) UTXOs.
     *
     * @param txId a unique identifier for this transaction which must not have been used before
     * @param lockId unique identifier for the lock
     * @param lockedInputs array of zero or more UTXOs locked by the given lockId
     * @param lockedOutputs array of zero or more locked UTXOs to generate, which will be tied to the lockId
     * @param outputs array of zero or more new UTXOs to generate, for future transactions to spend
     * @param proof implementation-specific proof for this transaction - may be validated by
     *              the smart contract, or may represent evidence of off-chain validation
     * @param data any additional transaction data (opaque to the blockchain)
     *
     * Emits a {TransferLocked} event.
     */
    function transferLocked(
        bytes32 txId,
        bytes32 lockId,
        bytes32[] calldata lockedInputs,
        bytes32[] calldata lockedOutputs,
        bytes32[] calldata outputs,
        bytes calldata proof,
        bytes calldata data
    ) external;

    /**
     * @dev Update the current options for a lock.
     *      Should only be allowed if the lock has not been delegated.
     *
     * @param txId a unique identifier for this transaction which must not have been used before
     * @param lockId unique identifier for the lock
     * @param lockedInputs array of zero or more UTXOs locked by the given lockId
     *                     (will not be modified, but will be confirmed to be valid states
     *                     still locked by the given lockId)
     * @param options implementation-specific options that control how the lock may be utilized
     *                (may include restrictions on how it may be unlocked, expiration times, etc)
     * @param proof implementation-specific proof for this transaction - may be validated by
     *              the smart contract, or may represent evidence of off-chain validation
     * @param data any additional transaction data (opaque to the blockchain)
     *
     * Emits a {LockUpdate} event.
     */
    function setLockOptions(
        bytes32 txId,
        bytes32 lockId,
        bytes32[] calldata lockedInputs,
        bytes calldata options,
        bytes calldata proof,
        bytes calldata data
    ) external;

    /**
     * @dev Pass control of a lock to a new delegate.
     *      The delegate may be set by the lock creator if no delegate has been set yet, or
     *      it may be re-delegated by the current delegate.
     *
     * @param txId a unique identifier for this transaction which must not have been used before
     * @param lockId unique identifier for the lock
     * @param delegate the address of the delegate who can spend the locked states
     *                 (may be zero to set no delegate)
     * @param proof implementation-specific proof for this transaction - may be validated by
     *              the smart contract, or may represent evidence of off-chain validation
     * @param data any additional transaction data (opaque to the blockchain)
     *
     * Emits a {LockDelegated} event.
     */
    function delegateLock(
        bytes32 txId,
        bytes32 lockId,
        address delegate,
        bytes calldata proof,
        bytes calldata data
    ) external;

    /**
     * @dev query whether a TXO is currently locked
     * @param id the UTXO identifier
     * @return locked true or false depending on whether the identifier is locked
     */
    function isLocked(bytes32 id) external view returns (bool locked);

    /**
     * @dev query the lockId for a locked TXO
     * @param id the UTXO identifier
     */
    function getLockId(bytes32 id) external view returns (bytes32 lockId);

    /**
     * @dev query the current delegate for a lock
     * @param lockId the lockId set when the lock was created
     */
    function getLockDelegate(
        bytes32 lockId
    ) external view returns (address delegate);
}
