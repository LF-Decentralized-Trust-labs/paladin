// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	rpcserver "github.com/kaleido-io/paladin/kata/internal/rpcserver"
	statestore "github.com/kaleido-io/paladin/kata/internal/statestore"
	mock "github.com/stretchr/testify/mock"
)

// StateStore is an autogenerated mock type for the StateStore type
type StateStore struct {
	mock.Mock
}

// Close provides a mock function with given fields:
func (_m *StateStore) Close() {
	_m.Called()
}

// RPCModule provides a mock function with given fields:
func (_m *StateStore) RPCModule() *rpcserver.RPCModule {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for RPCModule")
	}

	var r0 *rpcserver.RPCModule
	if rf, ok := ret.Get(0).(func() *rpcserver.RPCModule); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*rpcserver.RPCModule)
		}
	}

	return r0
}

// RunInDomainContext provides a mock function with given fields: domainID, fn
func (_m *StateStore) RunInDomainContext(domainID string, fn statestore.DomainContextFunction) error {
	ret := _m.Called(domainID, fn)

	if len(ret) == 0 {
		panic("no return value specified for RunInDomainContext")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(string, statestore.DomainContextFunction) error); ok {
		r0 = rf(domainID, fn)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewStateStore creates a new instance of StateStore. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewStateStore(t interface {
	mock.TestingT
	Cleanup(func())
}) *StateStore {
	mock := &StateStore{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
