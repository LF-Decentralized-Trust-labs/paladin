// Code generated by mockery v2.43.2. DO NOT EDIT.

package mocks

import (
	driver "database/sql/driver"

	filters "github.com/kaleido-io/paladin/kata/internal/filters"
	mock "github.com/stretchr/testify/mock"
)

// Traverser is an autogenerated mock type for the Traverser type
type Traverser[T interface{}] struct {
	mock.Mock
}

// And provides a mock function with given fields: ot
func (_m *Traverser[T]) And(ot T) filters.Traverser[T] {
	ret := _m.Called(ot)

	if len(ret) == 0 {
		panic("no return value specified for And")
	}

	var r0 filters.Traverser[T]
	if rf, ok := ret.Get(0).(func(T) filters.Traverser[T]); ok {
		r0 = rf(ot)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(filters.Traverser[T])
		}
	}

	return r0
}

// BuildOr provides a mock function with given fields: ot
func (_m *Traverser[T]) BuildOr(ot ...T) filters.Traverser[T] {
	_va := make([]interface{}, len(ot))
	for _i := range ot {
		_va[_i] = ot[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	if len(ret) == 0 {
		panic("no return value specified for BuildOr")
	}

	var r0 filters.Traverser[T]
	if rf, ok := ret.Get(0).(func(...T) filters.Traverser[T]); ok {
		r0 = rf(ot...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(filters.Traverser[T])
		}
	}

	return r0
}

// Error provides a mock function with given fields:
func (_m *Traverser[T]) Error() error {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Error")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func() error); ok {
		r0 = rf()
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IsEqual provides a mock function with given fields: e, fieldName, field, testValue
func (_m *Traverser[T]) IsEqual(e *filters.FilterJSONKeyValue, fieldName string, field filters.FieldResolver, testValue driver.Value) filters.Traverser[T] {
	ret := _m.Called(e, fieldName, field, testValue)

	if len(ret) == 0 {
		panic("no return value specified for IsEqual")
	}

	var r0 filters.Traverser[T]
	if rf, ok := ret.Get(0).(func(*filters.FilterJSONKeyValue, string, filters.FieldResolver, driver.Value) filters.Traverser[T]); ok {
		r0 = rf(e, fieldName, field, testValue)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(filters.Traverser[T])
		}
	}

	return r0
}

// IsGreaterThan provides a mock function with given fields: e, fieldName, field, testValue
func (_m *Traverser[T]) IsGreaterThan(e *filters.FilterJSONKeyValue, fieldName string, field filters.FieldResolver, testValue driver.Value) filters.Traverser[T] {
	ret := _m.Called(e, fieldName, field, testValue)

	if len(ret) == 0 {
		panic("no return value specified for IsGreaterThan")
	}

	var r0 filters.Traverser[T]
	if rf, ok := ret.Get(0).(func(*filters.FilterJSONKeyValue, string, filters.FieldResolver, driver.Value) filters.Traverser[T]); ok {
		r0 = rf(e, fieldName, field, testValue)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(filters.Traverser[T])
		}
	}

	return r0
}

// IsGreaterThanOrEqual provides a mock function with given fields: e, fieldName, field, testValue
func (_m *Traverser[T]) IsGreaterThanOrEqual(e *filters.FilterJSONKeyValue, fieldName string, field filters.FieldResolver, testValue driver.Value) filters.Traverser[T] {
	ret := _m.Called(e, fieldName, field, testValue)

	if len(ret) == 0 {
		panic("no return value specified for IsGreaterThanOrEqual")
	}

	var r0 filters.Traverser[T]
	if rf, ok := ret.Get(0).(func(*filters.FilterJSONKeyValue, string, filters.FieldResolver, driver.Value) filters.Traverser[T]); ok {
		r0 = rf(e, fieldName, field, testValue)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(filters.Traverser[T])
		}
	}

	return r0
}

// IsIn provides a mock function with given fields: e, fieldName, field, testValues
func (_m *Traverser[T]) IsIn(e *filters.FilterJSONKeyValues, fieldName string, field filters.FieldResolver, testValues []driver.Value) filters.Traverser[T] {
	ret := _m.Called(e, fieldName, field, testValues)

	if len(ret) == 0 {
		panic("no return value specified for IsIn")
	}

	var r0 filters.Traverser[T]
	if rf, ok := ret.Get(0).(func(*filters.FilterJSONKeyValues, string, filters.FieldResolver, []driver.Value) filters.Traverser[T]); ok {
		r0 = rf(e, fieldName, field, testValues)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(filters.Traverser[T])
		}
	}

	return r0
}

// IsLessThan provides a mock function with given fields: e, fieldName, field, testValue
func (_m *Traverser[T]) IsLessThan(e *filters.FilterJSONKeyValue, fieldName string, field filters.FieldResolver, testValue driver.Value) filters.Traverser[T] {
	ret := _m.Called(e, fieldName, field, testValue)

	if len(ret) == 0 {
		panic("no return value specified for IsLessThan")
	}

	var r0 filters.Traverser[T]
	if rf, ok := ret.Get(0).(func(*filters.FilterJSONKeyValue, string, filters.FieldResolver, driver.Value) filters.Traverser[T]); ok {
		r0 = rf(e, fieldName, field, testValue)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(filters.Traverser[T])
		}
	}

	return r0
}

// IsLessThanOrEqual provides a mock function with given fields: e, fieldName, field, testValue
func (_m *Traverser[T]) IsLessThanOrEqual(e *filters.FilterJSONKeyValue, fieldName string, field filters.FieldResolver, testValue driver.Value) filters.Traverser[T] {
	ret := _m.Called(e, fieldName, field, testValue)

	if len(ret) == 0 {
		panic("no return value specified for IsLessThanOrEqual")
	}

	var r0 filters.Traverser[T]
	if rf, ok := ret.Get(0).(func(*filters.FilterJSONKeyValue, string, filters.FieldResolver, driver.Value) filters.Traverser[T]); ok {
		r0 = rf(e, fieldName, field, testValue)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(filters.Traverser[T])
		}
	}

	return r0
}

// IsLike provides a mock function with given fields: e, fieldName, field, testValue
func (_m *Traverser[T]) IsLike(e *filters.FilterJSONKeyValue, fieldName string, field filters.FieldResolver, testValue driver.Value) filters.Traverser[T] {
	ret := _m.Called(e, fieldName, field, testValue)

	if len(ret) == 0 {
		panic("no return value specified for IsLike")
	}

	var r0 filters.Traverser[T]
	if rf, ok := ret.Get(0).(func(*filters.FilterJSONKeyValue, string, filters.FieldResolver, driver.Value) filters.Traverser[T]); ok {
		r0 = rf(e, fieldName, field, testValue)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(filters.Traverser[T])
		}
	}

	return r0
}

// IsNull provides a mock function with given fields: e, fieldName, field
func (_m *Traverser[T]) IsNull(e *filters.FilterJSONBase, fieldName string, field filters.FieldResolver) filters.Traverser[T] {
	ret := _m.Called(e, fieldName, field)

	if len(ret) == 0 {
		panic("no return value specified for IsNull")
	}

	var r0 filters.Traverser[T]
	if rf, ok := ret.Get(0).(func(*filters.FilterJSONBase, string, filters.FieldResolver) filters.Traverser[T]); ok {
		r0 = rf(e, fieldName, field)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(filters.Traverser[T])
		}
	}

	return r0
}

// Limit provides a mock function with given fields: l
func (_m *Traverser[T]) Limit(l int) filters.Traverser[T] {
	ret := _m.Called(l)

	if len(ret) == 0 {
		panic("no return value specified for Limit")
	}

	var r0 filters.Traverser[T]
	if rf, ok := ret.Get(0).(func(int) filters.Traverser[T]); ok {
		r0 = rf(l)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(filters.Traverser[T])
		}
	}

	return r0
}

// NewRoot provides a mock function with given fields:
func (_m *Traverser[T]) NewRoot() filters.Traverser[T] {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for NewRoot")
	}

	var r0 filters.Traverser[T]
	if rf, ok := ret.Get(0).(func() filters.Traverser[T]); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(filters.Traverser[T])
		}
	}

	return r0
}

// Order provides a mock function with given fields: f
func (_m *Traverser[T]) Order(f string) filters.Traverser[T] {
	ret := _m.Called(f)

	if len(ret) == 0 {
		panic("no return value specified for Order")
	}

	var r0 filters.Traverser[T]
	if rf, ok := ret.Get(0).(func(string) filters.Traverser[T]); ok {
		r0 = rf(f)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(filters.Traverser[T])
		}
	}

	return r0
}

// Result provides a mock function with given fields:
func (_m *Traverser[T]) Result() T {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Result")
	}

	var r0 T
	if rf, ok := ret.Get(0).(func() T); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(T)
	}

	return r0
}

// WithError provides a mock function with given fields: err
func (_m *Traverser[T]) WithError(err error) filters.Traverser[T] {
	ret := _m.Called(err)

	if len(ret) == 0 {
		panic("no return value specified for WithError")
	}

	var r0 filters.Traverser[T]
	if rf, ok := ret.Get(0).(func(error) filters.Traverser[T]); ok {
		r0 = rf(err)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(filters.Traverser[T])
		}
	}

	return r0
}

// NewTraverser creates a new instance of Traverser. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewTraverser[T interface{}](t interface {
	mock.TestingT
	Cleanup(func())
}) *Traverser[T] {
	mock := &Traverser[T]{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
