/*
 * Copyright Â© 2024 Kaleido, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 */

syntax = "proto3";

package paladin.kata;
option go_package = "pkg/proto";

service KataMessageService {
  // Bidirectional stream to receive messages. 
  rpc Listen(ListenRequest) returns (stream Message) {}
  
  //TODO need to think carefully how to do this without allowing one plugin to stop a listener for another
  // for now, the listeners thread will stop when the context is cancelled (e.g. connection is dopped)
  //rpc StopListener() returns (stream Message) {}
  // Simple RPC to Subscribe to an event, request provides the destination name for the listener
  // to recieve events on the given topic
  rpc SubscribeEvent(SubscribeEventRequest) returns (SubscribeEventResponse) {}

  // Simple RPC to Send a message to a specified destination
  rpc SendMessage(Message) returns (SendMessageResponse) {}

  // Simple RPC to publish an event to all subscribers of a given topic
  rpc PublishEvent(Event) returns (PublishEventResponse) {}

  rpc Status(StatusRequest) returns (StatusResponse) {}

  // get a list of all listeners (internal components and other plugins) 
  rpc ListDestinations(ListDestinationsRequest) returns (ListDestinationsResponse) {}
}

// Not sure if we need Quiesce messages rather than relying gRPC to gracefully close the streams
message QuiesceStreamRequest {
}

message QuiesceStreamResponse {
}

message ListDestinationsRequest {}

message ListDestinationsResponse {
  repeated string destinations = 1;
}

message StatusRequest {}

message StatusResponse {
  bool ok = 1;
}

message ListenRequest {
  // unique id for this destination, can be used by other plugins to send messages directly to this listener
  // and also used when subscribing to events
  string destination = 1;
}

message Message {
  string destination = 1;
  string type = 2;
  string id = 3;
  optional string correlationId = 4;
  string body = 5;
  optional string replyTo = 6;
}

enum SEND_MESSAGE_RESULT {
  SEND_MESSAGE_OK   = 0;
  SEND_MESSAGE_FAIL = 1;
}

message SendMessageResponse {
  SEND_MESSAGE_RESULT result = 1;
  //if result is "OK" then reason is omitted otherwise, reason contains an error code explaining the non OK result
  optional string reason = 2;
}

enum PUBLISH_EVENT_RESULT {
  PUBLISH_EVENT_OK   = 0;
  PUBLISH_EVENT_FAIL = 1;
}

message PublishEventResponse {
  PUBLISH_EVENT_RESULT result = 1;
  //if result is "OK" then reason is omitted otherwise, reason contains an error code explaining the non OK result
  optional string reason = 2;
}

enum SUBSCRIBE_EVENT_RESULT {
  SUBSCRIBE_EVENT_OK   = 0;
  SUBSCRIBE_EVENT_FAIL = 1;
}

message SubscribeEventRequest {
  string topic = 1;
  string destination = 2;
}

message SubscribeEventResponse {
  SUBSCRIBE_EVENT_RESULT result = 1;
  //if result is "OK" then reason is omitted otherwise, reason contains an error code explaining the non OK result
  optional string reason = 2;
}

message Event {
  string topic = 1;
  string type = 2;
  string id = 3;
  string body = 4;
}
